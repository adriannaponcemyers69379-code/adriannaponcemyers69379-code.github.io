<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Particle Planet</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* 深空黑背景 */
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            user-select: none;
            font-size: 12px;
            z-index: 10;
        }

        .instruction {
            margin-bottom: 4px;
        }
        
        .accent {
            color: #ffaa00;
        }
    </style>
    <!-- 引入 ES Module Shims 以支持 import map -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui">
        <div class="instruction"><span class="accent">[DRAG]</span> 拖拽旋转视角</div>
        <div class="instruction"><span class="accent">[SCROLL]</span> 滚轮缩放</div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 配置参数 ---
        const CONFIG = {
            planetRadius: 40,
            planetParticles: 20000, 
            // 荧光感配色：深红橙色 -> 亮橙金色
            planetColor: 0xff3300, 
            planetCoreColor: 0xffaa00, 
            
            ringInnerRadius: 55,
            ringOuterRadius: 90,
            // 粒子暴增 + 尺寸微调 = 细腻荧光感
            ringParticles: 20000, 
            ringColor: 0xffffff,
            
            cameraMinDist: 50,
            cameraMaxDist: 300,
            zoomSpeed: 0.1,
            rotateSpeed: 0.005,
            
            autoRotateSpeed: 0.0005
        };

        // --- 场景初始化 ---
        const scene = new THREE.Scene();
        // 添加微弱雾气增加深度感
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 针对高分屏优化
        document.body.appendChild(renderer.domElement);

        // --- 辅助函数：生成圆形发光纹理 ---
        // 动态生成 Canvas 纹理，避免加载外部图片文件
        function createParticleTexture(isCore = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            
            if (isCore) {
                // 星球核心纹理：白核更大，制造“热源”感
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)'); 
                gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            } else {
                // 光环纹理：中心锐利，边缘柔和
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            }
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const particleTexture = createParticleTexture(false);
        const planetTexture = createParticleTexture(true); 

        // --- 创建星球 ---
        function createPlanet() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            const colorInside = new THREE.Color(CONFIG.planetCoreColor);
            const colorOutside = new THREE.Color(CONFIG.planetColor);

            for (let i = 0; i < CONFIG.planetParticles; i++) {
                // 球面均匀分布算法
                const r = CONFIG.planetRadius;
                const phi = Math.acos(-1 + (2 * i) / CONFIG.planetParticles);
                const theta = Math.sqrt(CONFIG.planetParticles * Math.PI) * phi;

                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);

                // 表面微弱起伏
                const variance = (Math.random() - 0.5) * 1.5;
                positions.push(x + variance, y + variance, z + variance);

                // 大小随机
                sizes.push(Math.random() * 0.8 + 0.2); 

                // 颜色插值：核心亮，外部暗
                const mixFactor = Math.pow(Math.random(), 2);
                const mixedColor = colorInside.clone().lerp(colorOutside, mixFactor);
                
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.6, 
                map: planetTexture, 
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 加法混合，越叠加越亮
                depthWrite: false,
                transparent: true,
                opacity: 1.0 
            });

            return new THREE.Points(geometry, material);
        }

        // --- 创建光环 ---
        function createRings() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < CONFIG.ringParticles; i++) {
                const r = CONFIG.ringInnerRadius + Math.random() * (CONFIG.ringOuterRadius - CONFIG.ringInnerRadius);
                const theta = Math.random() * Math.PI * 2;
                
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                // 极度压缩 Y 轴高度，形成锋利的圆环
                const y = (Math.random() - 0.5) * 0.5; 

                positions.push(x, y, z);
                colors.push(1, 1, 1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.6, // 稍微调大，配合高不透明度
                map: particleTexture,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 关键：产生荧光效果
                depthWrite: false,
                transparent: true,
                opacity: 1.0 // 亮度拉满
            });

            const ringMesh = new THREE.Points(geometry, material);
            
            // 倾斜光环
            ringMesh.rotation.x = Math.PI / 6; 
            ringMesh.rotation.z = Math.PI / 12;

            return ringMesh;
        }

        const planet = createPlanet();
        const rings = createRings();
        
        scene.add(planet);
        scene.add(rings);


        // --- 交互逻辑 (原生 JS) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // 使用球坐标系控制相机位置
        const spherical = {
            radius: 120, 
            theta: Math.PI / 4, 
            phi: Math.PI / 3   
        };

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            document.body.style.cursor = 'grabbing';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            document.body.style.cursor = 'default';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };

            spherical.theta -= deltaMove.x * CONFIG.rotateSpeed;
            spherical.phi -= deltaMove.y * CONFIG.rotateSpeed;
            // 限制垂直旋转角度，防止翻转
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('wheel', (e) => {
            const zoomAmount = e.deltaY * CONFIG.zoomSpeed;
            spherical.radius += zoomAmount;
            // 限制缩放范围
            spherical.radius = Math.max(CONFIG.cameraMinDist, Math.min(CONFIG.cameraMaxDist, spherical.radius));
        }, { passive: true });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            // 自转动画
            planet.rotation.y += CONFIG.autoRotateSpeed;
            rings.rotation.z -= CONFIG.autoRotateSpeed * 0.5; 
            
            // 更新相机位置
            camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.position.y = spherical.radius * Math.cos(spherical.phi);
            camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
